# Ex. No:1b 			Study of Client Server Chat Applications

## Aim: 
To perform a study on Client Server Chat Applications
## Introduction:
Client-server chat applications are a category of networked software that enables real-time communication between users over a network. This study explores the key components, architecture, and considerations in the development of client-server chat applications, highlighting their significance and common implementation practices.
Client-server chat applications are software systems that enable real-time communication between users over a network. These applications follow a client-server model, where one component (the server) manages connections and facilitates communication, while the other component (the client) interacts with the server to send and receive messages. Below are the fundamental aspects and components involved in the basics of client-server chat applications:
## 1. Client-Server Model:
•	Server:
•	The server is a central component that listens for incoming connections from clients.
•	It manages the communication channels and facilitates the exchange of messages between clients.
•	It may handle user authentication, message routing, and other core functionalities.
•	Client:
•	Clients are users or devices that connect to the server to participate in the chat.
•	Each client has a unique identity, often represented by a username.
•	Clients interact with the server to send and receive messages.
## 2. Communication Protocols:
•	Communication between clients and servers often relies on established protocols. The choice of protocol influences the behavior of the chat application.
•	TCP (Transmission Control Protocol):
•	Provides reliable, connection-oriented communication.
•	Ensures the ordered and error-free exchange of messages.

•	UDP (User Datagram Protocol):
•	Connectionless and operates in a best-effort mode.
•	Faster but may result in message loss or disorder.
## 3. Socket Programming:
•	Sockets:

•	Sockets serve as communication endpoints.
•	Each client and the server has a socket for sending and receiving data.

•	Functions:
•	Socket programming involves functions for creating, binding, listening, accepting connections, and sending/receiving data through sockets.
## 4. User Authentication:
•	For security and privacy, chat applications often implement user authentication mechanisms.
•	Users are required to provide credentials (e.g., username and password) to access the chat system.
•	More advanced methods like tokens or secure protocols can enhance authentication.
5. Message Routing:
•	The server is responsible for routing messages from one client to another.
•	It ensures that messages are delivered to the intended recipients.
•	Message routing may involve maintaining a list of connected users and their associated sockets.

## Architecture:
## Client-Server Model:
Client-server chat applications typically follow the client-server model, where one entity acts as the server, managing connections and facilitating communication, and one or more entities act as clients, initiating communication with the server.

## Communication Protocols:
The choice of communication protocol is crucial. Many chat applications use TCP (Transmission Control Protocol) for reliable, connection-oriented communication to ensure the ordered and error-free exchange of messages.
User Authentication:
User authentication mechanisms are essential to ensure secure and authorized access to the chat system. This can involve username-password authentication or more advanced methods like tokens.
## Components of Client-Server Chat Applications:
## Server-Side Components:

•	Socket Handling: The server manages incoming client connections using sockets, creating a separate thread or process for each connected client.
•	User Management: Maintaining information about connected users, their status, and handling login/logout functionality.
•	Message Routing: Implementing logic to route messages from one client to another, ensuring proper delivery.

## Considerations in Development:
1.	Concurrency and Multithreading:
•	Chat applications often require handling multiple connections simultaneously. The server must be designed to support concurrency, commonly achieved through multithreading or asynchronous programming.
2.	Security:
•	Ensuring the security of user data and messages is paramount. Encryption techniques, such as SSL/TLS, can be implemented to secure data in transit. Proper user authentication mechanisms help prevent unauthorized access.
3.	Scalability:
•	As the number of users grows, the chat application must be scalable. This involves optimizing server-side architecture to handle increasing loads efficiently.
4.	Persistence:
•	Some chat applications implement message persistence, allowing users to retrieve past messages. This may involve using databases to store and retrieve chat history.

5.	Notification Systems:
•	Implementing real-time notifications to inform users of new messages, user presence changes, or other relevant events.


Client-server chat applications are versatile tools that facilitate real-time communication between users over a network. They incorporate various components, including server-side and client-side elements, and must consider factors such as security, scalability, and concurrency. As technology continues to advance, client-server chat applications remain integral for collaborative communication in various domains.

Client-server chat applications are foundational to real-time communication over networks. They incorporate principles of socket programming, communication protocols, and security mechanisms to provide a seamless user experience. Understanding the basics of client-server chat applications is essential for developers involved in networked application development, as they form the backbone of various collaborative communication systems. As technology evolves, chat applications continue to adapt, incorporating new features and technologies to enhance user interaction and connectivity.

##client side program:

#Algorithm: Stop-and-Wait Server using Sockets

1.Start the program.

2.Import the socket module.

3.Create a server socket using socket().

4.Bind the socket to the local host and a specific port number (12345).

5.Put the server into listening mode to wait for client connections.

6.Display a message indicating the server is waiting for a connection.

7.Accept the incoming client connection and obtain the connection object and client address.

8.Display the client’s address after successful connection.

9.Repeat the following steps until termination:

10.Decode the received data.

11.Send an acknowledgment ("ACK") to the client.

12.Display confirmation that ACK is sent.

13.Close the client connection.

14.Close the server socket.

### Program:
~~~
import socket

# Create socket
server_socket = socket.socket()
server_socket.bind(('localhost', 12345))
server_socket.listen(1)

print("Server is waiting for connection...")

conn, addr = server_socket.accept()
print("Connected to client:", addr)

while True:
    frame = conn.recv(1024).decode()

    if frame == "exit":
        print("Transmission completed.")
        break

    print("Received frame:", frame)

    # Send ACK
    ack = "ACK"
    conn.send(ack.encode())
    print("ACK sent\n")

conn.close()
server_socket.close()
~~~
### client server program :
Algorithm: Client Program for Sending Frames Using Socket Programming

Step 1: Start the program.

Step 2: Import required modules

socket for network communication

time for delay between frames

Step 3: Create a client socket using the socket library.

Step 4: Connect the client socket to the server using

Host name: localhost

Port number: 12345

Step 5: Read the number of frames n from the user.

Step 6: Initialize a loop from i = 1 to n.

Step 7: For each iteration:

Create a frame message as "Frame i".

Send the frame to the server.

Wait to receive the acknowledgment (ACK) from the server.

Display the received ACK.

Wait for 1 second before sending the next frame.

Step 8: After all frames are sent, send the message "exit" to the server.

Step 9: Close the client socket.

Step 10: Stop the program.

###Program:
~~~
import socket
import time

# Create socket
client_socket = socket.socket()
client_socket.connect(('localhost', 12345))

n = int(input("Enter number of frames to send: "))

for i in range(1, n + 1):
    frame = f"Frame {i}"
    print("Sending:", frame)
    client_socket.send(frame.encode())

    # Wait for ACK
    ack = client_socket.recv(1024).decode()
    print("Received:", ack)
    time.sleep(1)

client_socket.send("exit".encode())
client_socket.close()
~~~

## output:

<img width="1441" height="649" alt="Screenshot 2026-02-12 162117" src="https://github.com/user-attachments/assets/235790de-8f90-47d1-8774-bfb9616dcaad" />

## Result:

Thus the study on Client Server Chat Applications has been performed

